// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createChunk = `-- name: CreateChunk :one
INSERT INTO code_chunks (symbol_name, symbol_type, start_line, end_line, content, doc, embedding, token_count, sha256, package)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, symbol_name, symbol_type, package, start_line, end_line, content, doc, receiver_name, embedding, token_count, sha256, created_at
`

type CreateChunkParams struct {
	SymbolName string
	SymbolType string
	StartLine  int32
	EndLine    int32
	Content    string
	Doc        pgtype.Text
	Embedding  pgvector.Vector
	TokenCount int32
	Sha256     string
	Package    string
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (CodeChunk, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.SymbolName,
		arg.SymbolType,
		arg.StartLine,
		arg.EndLine,
		arg.Content,
		arg.Doc,
		arg.Embedding,
		arg.TokenCount,
		arg.Sha256,
		arg.Package,
	)
	var i CodeChunk
	err := row.Scan(
		&i.ID,
		&i.SymbolName,
		&i.SymbolType,
		&i.Package,
		&i.StartLine,
		&i.EndLine,
		&i.Content,
		&i.Doc,
		&i.ReceiverName,
		&i.Embedding,
		&i.TokenCount,
		&i.Sha256,
		&i.CreatedAt,
	)
	return i, err
}

type CreateChunksParams struct {
	SymbolName   string
	SymbolType   string
	StartLine    int32
	EndLine      int32
	Content      string
	Doc          pgtype.Text
	ReceiverName pgtype.Text
	Embedding    pgvector.Vector
	TokenCount   int32
	Sha256       string
	Package      string
}

const findSimilarChunks = `-- name: FindSimilarChunks :many
SELECT id, symbol_name, symbol_type, package, start_line, end_line, content, doc, receiver_name, embedding, token_count, sha256, created_at,
       embedding <-> $1 AS distance
FROM code_chunks
ORDER BY embedding <-> $1
LIMIT $2
`

type FindSimilarChunksParams struct {
	Embedding pgvector.Vector
	Limit     int32
}

type FindSimilarChunksRow struct {
	ID           pgtype.UUID
	SymbolName   string
	SymbolType   string
	Package      string
	StartLine    int32
	EndLine      int32
	Content      string
	Doc          pgtype.Text
	ReceiverName pgtype.Text
	Embedding    pgvector.Vector
	TokenCount   int32
	Sha256       string
	CreatedAt    pgtype.Timestamptz
	Distance     interface{}
}

func (q *Queries) FindSimilarChunks(ctx context.Context, arg FindSimilarChunksParams) ([]FindSimilarChunksRow, error) {
	rows, err := q.db.Query(ctx, findSimilarChunks, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindSimilarChunksRow
	for rows.Next() {
		var i FindSimilarChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.SymbolName,
			&i.SymbolType,
			&i.Package,
			&i.StartLine,
			&i.EndLine,
			&i.Content,
			&i.Doc,
			&i.ReceiverName,
			&i.Embedding,
			&i.TokenCount,
			&i.Sha256,
			&i.CreatedAt,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
